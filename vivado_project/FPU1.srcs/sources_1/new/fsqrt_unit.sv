`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2025/08/09 00:07:49
// Design Name: 
// Module Name: fsqrt_unit
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module fsqrt_unit(
    input  clk,
    input  rst,
    input  [63:0] data1,
    input  [1:0] fmt,
    input  [9:0] class1,
    output logic [63:0] result,
    output logic [4:0] flags
    );
localparam logic [6:0] SQRT_LUT[0:255] = '{
7'b0000000,
7'b0001000,
7'b0001011,
7'b0001101,
7'b0010000,
7'b0010001,
7'b0010011,
7'b0010101,
7'b0010110,
7'b0011000,
7'b0011001,
7'b0011010,
7'b0011011,
7'b0011100,
7'b0011101,
7'b0011110,
7'b0100000,
7'b0100000,
7'b0100001,
7'b0100010,
7'b0100011,
7'b0100100,
7'b0100101,
7'b0100110,
7'b0100111,
7'b0101000,
7'b0101000,
7'b0101001,
7'b0101010,
7'b0101011,
7'b0101011,
7'b0101100,
7'b0101101,
7'b0101101,
7'b0101110,
7'b0101111,
7'b0110000,
7'b0110000,
7'b0110001,
7'b0110001,
7'b0110010,
7'b0110011,
7'b0110011,
7'b0110100,
7'b0110101,
7'b0110101,
7'b0110110,
7'b0110110,
7'b0110111,
7'b0111000,
7'b0111000,
7'b0111001,
7'b0111001,
7'b0111010,
7'b0111010,
7'b0111011,
7'b0111011,
7'b0111100,
7'b0111100,
7'b0111101,
7'b0111101,
7'b0111110,
7'b0111110,
7'b0111111,
7'b1000000,
7'b1000000,
7'b1000000,
7'b1000001,
7'b1000001,
7'b1000010,
7'b1000010,
7'b1000011,
7'b1000011,
7'b1000100,
7'b1000100,
7'b1000101,
7'b1000101,
7'b1000110,
7'b1000110,
7'b1000111,
7'b1000111,
7'b1001000,
7'b1001000,
7'b1001000,
7'b1001001,
7'b1001001,
7'b1001010,
7'b1001010,
7'b1001011,
7'b1001011,
7'b1001011,
7'b1001100,
7'b1001100,
7'b1001101,
7'b1001101,
7'b1001101,
7'b1001110,
7'b1001110,
7'b1001111,
7'b1001111,
7'b1010000,
7'b1010000,
7'b1010000,
7'b1010001,
7'b1010001,
7'b1010001,
7'b1010010,
7'b1010010,
7'b1010011,
7'b1010011,
7'b1010011,
7'b1010100,
7'b1010100,
7'b1010101,
7'b1010101,
7'b1010101,
7'b1010110,
7'b1010110,
7'b1010110,
7'b1010111,
7'b1010111,
7'b1011000,
7'b1011000,
7'b1011000,
7'b1011001,
7'b1011001,
7'b1011001,
7'b1011010,
7'b1011010,
7'b1011010,
7'b1011011,
7'b1011011,
7'b1011011,
7'b1011100,
7'b1011100,
7'b1011100,
7'b1011101,
7'b1011101,
7'b1011101,
7'b1011110,
7'b1011110,
7'b1011110,
7'b1011111,
7'b1011111,
7'b1100000,
7'b1100000,
7'b1100000,
7'b1100000,
7'b1100001,
7'b1100001,
7'b1100001,
7'b1100010,
7'b1100010,
7'b1100010,
7'b1100011,
7'b1100011,
7'b1100011,
7'b1100100,
7'b1100100,
7'b1100100,
7'b1100101,
7'b1100101,
7'b1100101,
7'b1100110,
7'b1100110,
7'b1100110,
7'b1100111,
7'b1100111,
7'b1100111,
7'b1101000,
7'b1101000,
7'b1101000,
7'b1101000,
7'b1101001,
7'b1101001,
7'b1101001,
7'b1101010,
7'b1101010,
7'b1101010,
7'b1101011,
7'b1101011,
7'b1101011,
7'b1101011,
7'b1101100,
7'b1101100,
7'b1101100,
7'b1101101,
7'b1101101,
7'b1101101,
7'b1101101,
7'b1101110,
7'b1101110,
7'b1101110,
7'b1101111,
7'b1101111,
7'b1101111,
7'b1110000,
7'b1110000,
7'b1110000,
7'b1110000,
7'b1110001,
7'b1110001,
7'b1110001,
7'b1110001,
7'b1110010,
7'b1110010,
7'b1110010,
7'b1110011,
7'b1110011,
7'b1110011,
7'b1110011,
7'b1110100,
7'b1110100,
7'b1110100,
7'b1110101,
7'b1110101,
7'b1110101,
7'b1110101,
7'b1110110,
7'b1110110,
7'b1110110,
7'b1110110,
7'b1110111,
7'b1110111,
7'b1110111,
7'b1111000,
7'b1111000,
7'b1111000,
7'b1111000,
7'b1111001,
7'b1111001,
7'b1111001,
7'b1111001,
7'b1111010,
7'b1111010,
7'b1111010,
7'b1111010,
7'b1111011,
7'b1111011,
7'b1111011,
7'b1111011,
7'b1111100,
7'b1111100,
7'b1111100,
7'b1111100,
7'b1111101,
7'b1111101,
7'b1111101,
7'b1111101,
7'b1111110,
7'b1111110,
7'b1111110,
7'b1111110,
7'b1111111,
7'b1111111,
7'b1111111
};

localparam logic [7:0] RECIP_LUT[0:119] = '{
8'b10000000,
8'b01110001,
8'b01100110,
8'b01011101,
8'b01010101,
8'b01001110,
8'b01001001,
8'b01000100,
8'b01000000,
8'b00111100,
8'b00111000,
8'b00110101,
8'b00110011,
8'b00110000,
8'b00101110,
8'b00101100,
8'b00101010,
8'b00101000,
8'b00100111,
8'b00100101,
8'b00100100,
8'b00100011,
8'b00100010,
8'b00100001,
8'b00100000,
8'b00011111,
8'b00011110,
8'b00011101,
8'b00011100,
8'b00011011,
8'b00011010,
8'b00011010,
8'b00011001,
8'b00011000,
8'b00011000,
8'b00010111,
8'b00010111,
8'b00010110,
8'b00010110,
8'b00010101,
8'b00010101,
8'b00010100,
8'b00010100,
8'b00010100,
8'b00010011,
8'b00010011,
8'b00010010,
8'b00010010,
8'b00010010,
8'b00010001,
8'b00010001,
8'b00010001,
8'b00010001,
8'b00010000,
8'b00010000,
8'b00010000,
8'b00010000,
8'b00001111,
8'b00001111,
8'b00001111,
8'b00001111,
8'b00001110,
8'b00001110,
8'b00001110,
8'b00001110,
8'b00001110,
8'b00001101,
8'b00001101,
8'b00001101,
8'b00001101,
8'b00001101,
8'b00001100,
8'b00001100,
8'b00001100,
8'b00001100,
8'b00001100,
8'b00001100,
8'b00001100,
8'b00001011,
8'b00001011,
8'b00001011,
8'b00001011,
8'b00001011,
8'b00001011,
8'b00001011,
8'b00001011,
8'b00001010,
8'b00001010,
8'b00001010,
8'b00001010,
8'b00001010,
8'b00001010,
8'b00001010,
8'b00001010,
8'b00001010,
8'b00001001,
8'b00001001,
8'b00001001,
8'b00001001,
8'b00001001,
8'b00001001,
8'b00001001,
8'b00001001,
8'b00001001,
8'b00001001,
8'b00001001,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000,
8'b00001000
};

// 状态编码
localparam IDLE  = 2'd0;  // 空闲状态
localparam INIT  = 2'd1;  // 初始化状态
localparam ITER  = 2'd2;  // 迭代计算状态
localparam NORM  = 2'd3;  // 规格化状态

reg [1:0] state;         // 当前状态
reg [3:0] iter_count;     // 迭代计数器
reg [63:0] data_reg;        // 输入寄存器
reg fmt_reg;             // 精度寄存器

// 计算中间变量
reg [53:0] q;           
reg [53:0] r;           
reg [53:0] x;          
reg [53:0] y;           

// 变量与阶码开方
wire sign = fmt_reg ?data_reg[63]: data_reg[31];
wire [10:0] exponent = fmt_reg ? data_reg[62:52] : {3'b0, data_reg[30:23]};
wire [10:0] exponent_real= fmt_reg ? exponent - 11'd1023 : exponent - 11'd127;
wire [10:0] exponent_sqrt = exponent_real >> 1;
wire [10:0] exponent_out = exponent_sqrt + (fmt_reg ? 11'd1023 : 11'd127);
wire [51:0] mantissa = fmt_reg ? data_reg[51:0] : {data_reg[22:0], 29'b0};
wire [53:0] mantissa_conv=exponent_real[0]? {1'b1, mantissa, 1'b0} : {2'b01, mantissa};
wire [6:0] sqrt_lut_index = SQRT_LUT[mantissa_conv[53:46]];
wire [13:0] sqrt_lut_square = {sqrt_lut_index * sqrt_lut_index};
wire [7:0] recip_lut_index = (x[53:47]-7'b0001000>=0)? RECIP_LUT[x[53:47]-7'b0001000] : 8'b00000000;
wire [61:0] recip_sqrt_y={RECIP_LUT[sqrt_lut_index-7'b0001000]*y};
wire [61:0] recip_lut_y= {recip_lut_index * y};

always @(posedge clk or negedge rst) begin
    if (!rst) begin
        state <= IDLE;
        result <= 0;
        iter_count <= 0;
        data_reg <= 0;
        fmt_reg <= 0;
        q <= 0;
        x <= 0;
        y <= 0;
        flags <=0;
    end 
    else begin
        case (state)
            IDLE: begin
                    state <= INIT;
                    data_reg <= data1;
                    fmt_reg <= fmt[0];
            end
            
            INIT: begin
                if(sign)  begin
                    state <= IDLE;
                    result <= 0;
                    flags <= 5'b10000;
                end 
                else if (class1[4]) begin
                    state <= IDLE;
                    result <= 0;
                    flags <= 0;
                end 
                else if (class1[7]) begin
                        state <= IDLE;
                        result <= fmt_reg?{1'b0, {11{1'b1}}, {52{1'b0}}}:{33'b0, {8{1'b1}}, {23{1'b0}}};
                        flags <= 0;
                end 
                else if (class1[8] || class1[9]) begin
                        state <= IDLE;
                        result <= fmt_reg?{1'b0, {11{1'b1}}, 1'b1, {51{1'b0}}}:{33'b0, {8{1'b1}}, 1'b1, {22{1'b0}}};
                        flags <= 5'b10000;
                end 
                else  begin
                y <= mantissa_conv;
                q <= {sqrt_lut_index,47'b0};
                if (y=={sqrt_lut_square[12:0], 41'b0})
                    begin
                        flags <=5'b0;
                        state <= NORM;
                    end 
                    else begin
                        iter_count <= 0;
                        state <= ITER;
                    end
                end
            end
            
            ITER: begin
                // 牛顿迭代步骤(共6次)
                if (recip_lut_index == 8'b00000000) begin
                    result<=0;
                    flags <= 5'b0;
                    state <= IDLE;
                end else if (iter_count ==0) begin
                    x <={q+recip_sqrt_y[58:5]}>>1;
                end else if (iter_count < 5) begin
                    x<={x+recip_lut_y[58:5]}>>1;
                end else begin
                    state <= NORM;
                end
                iter_count <= iter_count + 1;
                flags <= 5'b00001;
            end
            
            NORM: begin
                result <= fmt_reg ? {1'b0, exponent_out, q[52:1]} : {33'b0, exponent_out[7:0], q[52:30]};
                state <= IDLE;
            end
        endcase
    end
end
endmodule